import { IInt } from './IInt';
import { INum } from '../GHC/Num';
import { ISemiring } from './Semiring';
import { IRing } from './Ring';
import { IEq } from './Eq';
import { IOrd } from './Ord';
import { IShow } from './Show';
import { Bool } from './Bool';
declare const URI: "Int";
declare type URI = typeof URI;
export { URI };
interface Int extends IInt {
    URI: URI;
}
export { Int };
declare let fromI: (_: IInt) => Int;
export { fromI };
declare let add: (_: Int) => (_: Int) => Int;
export { add };
declare let mul: (_: Int) => (_: Int) => Int;
export { mul };
declare let sub: (_: Int) => (_: Int) => Int;
export { sub };
declare let inc: (_: Int) => Int;
export { inc };
declare let dec: (_: Int) => Int;
export { dec };
declare let even: (_: Int) => Bool;
export { even };
declare let odd: (_: Int) => Bool;
export { odd };
declare let Num: INum<Int> & INum.Ext<Int>;
export { Num };
declare let Show: IShow<Int>;
export { Show };
declare let Semiring: ISemiring<Int>;
export { Semiring };
declare let Ring: IRing<Int>;
export { Ring };
declare let Eq: IEq<Int> & IEq.Ext<Int>;
export { Eq };
declare let Ord: IOrd<Int> & IOrd.Ext<Int>;
export { Ord };
declare let Int: ((value: number) => Int) & {
    URI: "Int";
    fromI: (_: IInt) => Int;
    add: (_: Int) => (_: Int) => Int;
    mul: (_: Int) => (_: Int) => Int;
    sub: (_: Int) => (_: Int) => Int;
    inc: (_: Int) => Int;
    dec: (_: Int) => Int;
    even: (_: Int) => Bool;
    odd: (_: Int) => Bool;
    Show: IShow<Int>;
    Semiring: ISemiring<Int>;
    Ring: IRing<Int>;
    Eq: IEq<Int> & IEq.Ext<Int>;
    Ord: IOrd<Int> & IOrd.Ext<Int>;
};
export default Int;
