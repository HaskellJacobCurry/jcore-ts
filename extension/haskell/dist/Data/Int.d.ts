import { IInt } from './IInt';
import { INum } from '../GHC/Num';
import { ISemiring } from './Semiring';
import { IRing } from './Ring';
import { IEq } from './Eq';
import { IOrd } from './Ord';
import { IShow } from './Show';
import { Bool } from './Bool';
import { Ordering } from './Ordering';
declare const URI: "Int";
declare type URI = typeof URI;
export { URI };
interface Int extends IInt {
    URI: URI;
}
export { Int };
declare let fromI: (_: IInt) => Int;
export { fromI };
declare let create: (value: number) => Int;
export { create };
declare let zero: () => Int;
export { zero };
declare let one: () => Int;
export { one };
declare let add: (_: Int) => (_: Int) => Int;
export { add };
declare let mul: (_: Int) => (_: Int) => Int;
export { mul };
declare let sub: (_: Int) => (_: Int) => Int;
export { sub };
declare let inc: (_: Int) => Int;
export { inc };
declare let dec: (_: Int) => Int;
export { dec };
declare let even: (_: Int) => Bool;
export { even };
declare let odd: (_: Int) => Bool;
export { odd };
declare let abs: (_: Int) => Int;
export { abs };
declare let negate: (_: Int) => Int;
export { negate };
declare let eq: (_: Int) => (_: Int) => Bool;
export { eq };
declare let notEq: (_: Int) => (_: Int) => Bool;
export { notEq };
declare let compare: (_: Int) => (_: Int) => Ordering;
export { compare };
declare let lt: (_: Int) => (_: Int) => Bool;
export { lt };
declare let notLt: (_: Int) => (_: Int) => Bool;
export { notLt };
declare let gt: (_: Int) => (_: Int) => Bool;
export { gt };
declare let notGt: (_: Int) => (_: Int) => Bool;
export { notGt };
declare let Num: INum<Int> & INum.Ext<Int>;
export { Num };
declare let Show: IShow<Int>;
export { Show };
declare let Semiring: ISemiring<Int>;
export { Semiring };
declare let Ring: IRing<Int>;
export { Ring };
declare let Eq: IEq<Int> & IEq.Ext<Int>;
export { Eq };
declare let Ord: IOrd<Int> & IOrd.Ext<Int>;
export { Ord };
declare let Int: ((value: number) => Int) & {
    URI: "Int";
    fromI: (_: IInt) => Int;
    zero: () => Int;
    one: () => Int;
    add: (_: Int) => (_: Int) => Int;
    mul: (_: Int) => (_: Int) => Int;
    sub: (_: Int) => (_: Int) => Int;
    inc: (_: Int) => Int;
    dec: (_: Int) => Int;
    even: (_: Int) => Bool;
    odd: (_: Int) => Bool;
    abs: (_: Int) => Int;
    negate: (_: Int) => Int;
    eq: (_: Int) => (_: Int) => Bool;
    notEq: (_: Int) => (_: Int) => Bool;
    compare: (_: Int) => (_: Int) => Ordering;
    lt: (_: Int) => (_: Int) => Bool;
    notLt: (_: Int) => (_: Int) => Bool;
    gt: (_: Int) => (_: Int) => Bool;
    notGt: (_: Int) => (_: Int) => Bool;
    Show: IShow<Int>;
    Semiring: ISemiring<Int>;
    Ring: IRing<Int>;
    Eq: IEq<Int> & IEq.Ext<Int>;
    Ord: IOrd<Int> & IOrd.Ext<Int>;
};
export default Int;
