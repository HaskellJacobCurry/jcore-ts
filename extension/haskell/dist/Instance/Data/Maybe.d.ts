import { Maybe, HMaybe as _HMaybe } from '../../DataStructure/Data/Maybe';
import { String } from './String';
import { IShow } from '../../Typeclass/Data/Show';
import { Functor1 } from '../../Typeclass/Data/Functor';
import { Apply1 } from '../../Typeclass/Control/Apply';
import { Applicative1 } from '../../Typeclass/Control/Applicative';
import { Bind1 } from '../../Typeclass/Control/Bind';
import { Monad1 } from '../../Typeclass/Control/Monad';
import { ISemigroup } from '../../Typeclass/Data/Semigroup';
import { IMonoid } from '../../Typeclass/Data/Monoid';
import { Foldable1 } from '../../Typeclass/Data/Foldable';
export * from '../../DataStructure/Data/Maybe';
declare let show: <A>(_: IShow<A>) => (_: Maybe<A>) => String;
export { show };
declare let bind: <A>(_: Maybe<A>) => <B>(_: (_: A) => Maybe<B>) => Maybe<B>;
export { bind };
declare let fmap: <A, B>(_: (_: A) => B) => (_: Maybe<A>) => Maybe<B>;
export { fmap };
declare let ap: <A, B>(_: Maybe<(_: A) => B>) => (_: Maybe<A>) => Maybe<B>;
export { ap };
declare let pure: <A>(_: A) => Maybe<A>;
export { pure };
declare let append: <A>(_: ISemigroup<A>) => (_: Maybe<A>) => (_: Maybe<A>) => Maybe<A>;
export { append };
declare let mempty: <A>() => Maybe<A>;
export { mempty };
declare let Show: <A>(_: IShow<A>) => IShow<Maybe<A>>;
export { Show };
declare let Functor: Functor1<"Maybe"> & Functor1.Ext<"Maybe">;
export { Functor };
declare let Apply: Functor1<"Maybe"> & Functor1.Ext<"Maybe"> & Apply1.Base<"Maybe"> & Apply1.Ext<"Maybe">;
export { Apply };
declare let Applicative: Functor1<"Maybe"> & Functor1.Ext<"Maybe"> & Apply1.Base<"Maybe"> & Apply1.Ext<"Maybe"> & Applicative1.Base<"Maybe">;
export { Applicative };
declare let Bind: Functor1<"Maybe"> & Functor1.Ext<"Maybe"> & Apply1.Base<"Maybe"> & Apply1.Ext<"Maybe"> & Bind1.Base<"Maybe"> & Bind1.Ext<"Maybe">;
export { Bind };
declare let Monad: Functor1<"Maybe"> & Functor1.Ext<"Maybe"> & Apply1.Base<"Maybe"> & Apply1.Ext<"Maybe"> & Applicative1.Base<"Maybe"> & Bind1.Base<"Maybe"> & Bind1.Ext<"Maybe"> & Monad1.Ext<"Maybe">;
export { Monad };
declare let Semigroup: <A>(_: ISemigroup<A>) => ISemigroup<Maybe<A>>;
export { Semigroup };
declare let Monoid: <A>(_: ISemigroup<A>) => ISemigroup<Maybe<A>> & IMonoid.Base<Maybe<A>> & IMonoid.Ext<Maybe<A>>;
export { Monoid };
declare let foldMap: <G>(_: IMonoid<G>) => <A>(_: (_: A) => G) => (_: Maybe<A>) => G;
export { foldMap };
declare let Foldable: Foldable1<"Maybe"> & Foldable1.Ext<"Maybe">;
export { Foldable };
interface HMaybe extends _HMaybe {
    Show: typeof Show;
    Functor: typeof Functor;
    Apply: typeof Apply;
    Applicative: typeof Applicative;
    Bind: typeof Bind;
    Monad: typeof Monad;
    Semigroup: typeof Semigroup;
    Monoid: typeof Monoid;
    Foldable: typeof Foldable;
    show: <A>(_: IShow<A>) => (_: Maybe<A>) => String;
    bind: <A>(_: Maybe<A>) => <B>(f: (_: A) => Maybe<B>) => Maybe<B>;
    fmap: <A, B>(_: (_: A) => B) => (_: Maybe<A>) => Maybe<B>;
    ap: <A, B>(_: Maybe<(_: A) => B>) => (_: Maybe<A>) => Maybe<B>;
    pure: <A>(_: A) => Maybe<A>;
    append: <A>(_: ISemigroup<A>) => (_: Maybe<A>) => (_: Maybe<A>) => Maybe<A>;
    mempty: <A>() => Maybe<A>;
    foldMap: <G>(_: IMonoid<G>) => <A>(_: (_: A) => G) => (_: Maybe<A>) => G;
}
declare type _Maybe<A> = Maybe<A>;
declare let _Maybe: HMaybe;
export { _Maybe as Maybe };
export default _Maybe;
